// Error type for the application
use once_cell::sync::OnceCell; // Added for OnceCell
use crate::context::AppContext;   // Added for AppContext
use std::path::Path;              // Added for path checking

// Error type for the application
#[derive(Debug)]
pub enum AppError {
    InputError(String),
    ArduinoError(String),
    ConfigError(String),      // For configuration loading errors
    TemplateError(String),    // For template loading errors
    ImageProcessingError(String), // For image processing errors (already used in matching.rs)
    ScreenCaptureError(String), // For screen capture errors (already used in capture.rs indirectly)
    InitializationError(String), // For errors during AppContext initialization
    MutexLockError(String), // For Mutex poisoning errors
    // Add other error variants as needed
}

// Implement Display for AppError to allow it to be printed easily
impl std::fmt::Display for AppError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            AppError::InputError(s) => write!(f, "Input Error: {}", s),
            AppError::ArduinoError(s) => write!(f, "Arduino Communication Error: {}", s),
            AppError::ConfigError(s) => write!(f, "Configuration Error: {}", s),
            AppError::TemplateError(s) => write!(f, "Template Error: {}", s),
            AppError::ImageProcessingError(s) => write!(f, "Image Processing Error: {}", s),
            AppError::ScreenCaptureError(s) => write!(f, "Screen Capture Error: {}", s),
            AppError::InitializationError(s) => write!(f, "Initialization Error: {}", s),
            AppError::MutexLockError(s) => write!(f, "Mutex Lock Error: {}", s),
        }
    }
}

// Implement Error for AppError to make it a valid error type
impl std::error::Error for AppError {}

// Global static instance of AppContext
static APP_CONTEXT: OnceCell<AppContext> = OnceCell::new();

/// Initializes and returns a reference to the global AppContext.
///
/// On the first call, it initializes AppContext using default paths:
/// - Config: "config.toml" (or "config/config.toml" if "config.toml" not found)
/// - Templates: "templates/"
///
/// Subsequent calls will return the already initialized instance.
pub fn global_app_context() -> Result<&'static AppContext, AppError> {
    APP_CONTEXT.get_or_try_init(|| {
        // Determine config path
        let config_path_str = if Path::new("config.toml").exists() {
            "config.toml"
        } else if Path::new("config/config.toml").exists() {
            "config/config.toml"
        } else {
            // Fallback or error if neither is found
            // For now, let AppContext::new handle the error if "config.toml" is hardcoded there
            // or prefer one and let it fail if not present.
            // Let's default to "config.toml" and if it's not found, AppContext::new will error out.
            "config.toml"
        };

        let templates_path_str = "templates/"; // Default templates directory

        AppContext::new(config_path_str, templates_path_str)
            .map_err(|e| AppError::InitializationError(format!("Failed to initialize AppContext: {}", e)))
    })
}


// Declare modules
pub mod config; // Assuming config module exists for settings
pub mod image_processing; // Assuming this module exists
pub mod input; // Contains arduino.rs and keyboard.rs
pub mod python_utils; // Contains PyO3 functions
pub mod context; // Newly added context module
pub mod screen_capture; // Assuming this module exists for capture functions

// The #[pymodule] in python_utils.rs (rust_utils_module) will be
// the entry point for the Python module generated by PyO3 for this crate.
// No further changes should be needed here for module exposure,
// assuming Cargo.toml is set up correctly for a cdylib.
